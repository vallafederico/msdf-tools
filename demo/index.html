<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>MSDF Preview</title>
    <style>
      :root {
        color-scheme: light;
      }
      body {
        margin: 0;
        font-family: "Helvetica Neue", Arial, sans-serif;
        background: #f7f7f9;
        color: #222;
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100vh;
      }
      header {
        padding: 12px 16px;
        display: flex;
        gap: 8px;
        align-items: center;
        background: #fff;
        border-bottom: 1px solid #e1e4e8;
      }
      header input[type="text"] {
        padding: 6px 8px;
        font: inherit;
        border: 1px solid #d0d7de;
        border-radius: 6px;
        min-width: 180px;
      }
      header button {
        padding: 8px 12px;
        font: inherit;
        border: 1px solid #0b66c3;
        background: #0d7ce1;
        color: #fff;
        border-radius: 6px;
        cursor: pointer;
      }
      header button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
      header label {
        display: flex;
        align-items: center;
        gap: 6px;
      }
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.166.1/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.166.1/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <header>
      <label
        >JSON <input id="jsonPath" type="text" value="../out/vector.json"
      /></label>
      <label
        >Text <input id="textInput" type="text" value="Hello MSDF"
      /></label>
      <button id="loadBtn">Load</button>
      <span id="status"></span>
    </header>
    <canvas id="c"></canvas>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      const canvas = document.getElementById("c");
      const renderer = new THREE.WebGLRenderer({
        canvas,
        antialias: true,
        alpha: false,
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0xffffff, 1);

      let scene = new THREE.Scene();
      let camera;
      let material;
      let mesh;
      let atlasMeta;
      let atlasTexture;
      let controls;

      const statusEl = document.getElementById("status");

      function setStatus(msg) {
        statusEl.textContent = msg;
      }

      function firstRenderableChar() {
        if (!atlasMeta) return "?";
        const g = atlasMeta.glyphs.find(
          (g) => (g.width ?? 0) > 0 && (g.height ?? 0) > 0,
        );
        return g ? String.fromCodePoint(g.id) : "?";
      }

      function renderableGlyphs() {
        if (!atlasMeta) return [];
        return atlasMeta.glyphs.filter(
          (g) => (g.width ?? 0) > 0 && (g.height ?? 0) > 0,
        );
      }

      function normalizeTextForAtlas(text) {
        if (!atlasMeta) return text;
        const available = new Set(atlasMeta.glyphs.map((g) => g.id));
        for (const ch of text) {
          const cp = ch.codePointAt(0);
          if (cp != null && available.has(cp)) return text;
        }
        const fallback = firstRenderableChar();
        return fallback;
      }

      function median3(v) {
        return Math.max(
          Math.min(v[0], v[1]),
          Math.min(Math.max(v[0], v[1]), v[2]),
        );
      }

      function buildGeometry(text) {
        if (!atlasMeta) throw new Error("Atlas not loaded");
        if (atlasMeta.pages.length > 1) {
          console.warn("Viewer uses first atlas page only");
        }

        const page = atlasMeta.pages[0];
        const glyphById = new Map(atlasMeta.glyphs.map((g) => [g.id, g]));

        const lineHeight = atlasMeta.metrics.lineHeight * atlasMeta.info.size;
        let penX = 0;
        let penY = 0;

        const positions = [];
        const uvs = [];
        const indices = [];
        let vert = 0;

        for (const ch of text) {
          if (ch === "\n") {
            penX = 0;
            penY -= lineHeight;
            continue;
          }
          const code = ch.codePointAt(0);
          const glyph = code !== undefined ? glyphById.get(code) : undefined;
          if (!glyph || glyph.width === 0 || glyph.height === 0) {
            penX += glyph?.xadvance ?? atlasMeta.info.size * 0.5;
            continue;
          }

          const x0 = penX + glyph.xoffset;
          const y0 = penY - glyph.yoffset;
          const x1 = x0 + glyph.width;
          const y1 = y0 + glyph.height;

          const u0 = glyph.x / page.width;
          const v0 = glyph.y / page.height;
          const u1 = (glyph.x + glyph.width) / page.width;
          const v1 = (glyph.y + glyph.height) / page.height;

          positions.push(x0, y0, 0, x1, y0, 0, x1, y1, 0, x0, y1, 0);
          uvs.push(u0, v1, u1, v1, u1, v0, u0, v0);
          indices.push(vert, vert + 1, vert + 2, vert, vert + 2, vert + 3);
          vert += 4;

          penX += glyph.xadvance;
        }

        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(positions, 3),
        );
        geometry.setAttribute("uv", new THREE.Float32BufferAttribute(uvs, 2));
        geometry.setIndex(indices);
        geometry.computeBoundingBox();
        return geometry;
      }

      async function loadAtlas(jsonPath) {
        setStatus("Loading atlas...");
        const baseUrl = new URL(jsonPath, window.location.href);
        const meta = await fetch(baseUrl).then((r) => {
          if (!r.ok) throw new Error(`HTTP ${r.status}`);
          return r.json();
        });
        const page = meta.pages[0];
        if (!page) throw new Error("Atlas pages missing");

        const tex = await new Promise((resolve, reject) => {
          new THREE.TextureLoader().load(
            new URL(page.file, baseUrl).toString(),
            (t) => {
              t.flipY = false;
              t.magFilter = THREE.LinearFilter;
              t.minFilter = THREE.LinearMipMapLinearFilter;
              resolve(t);
            },
            undefined,
            reject,
          );
        });
        atlasMeta = meta;
        atlasTexture = tex;
        setStatus(`Loaded ${baseUrl.pathname}`);
      }

      function setupScene(text) {
        scene = new THREE.Scene();

        const geometry = buildGeometry(text);
        geometry.computeBoundingBox();
        const bbox = geometry.boundingBox;
        if (bbox) {
          const center = new THREE.Vector3();
          bbox.getCenter(center);
          geometry.translate(-center.x, -center.y, 0);
        }

        const shader = {
          vertex: `
          precision highp float;
          attribute vec3 position;
          attribute vec2 uv;
          uniform mat4 modelViewMatrix;
          uniform mat4 projectionMatrix;
          varying vec2 vUv;
          void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
          fragment: `
          #if defined(GL_OES_standard_derivatives)
          #extension GL_OES_standard_derivatives : enable
          #define HAS_DERIVATIVES 1
          #else
          #define HAS_DERIVATIVES 0
          #endif
          precision highp float;
          uniform sampler2D uMap;
          uniform vec3 uColor;
          varying vec2 vUv;
          float median(float a, float b, float c) { return max(min(a, b), min(max(a, b), c)); }
          void main() {
            vec3 sample = texture2D(uMap, vUv).rgb;
            float sd = median(sample.r, sample.g, sample.b) - 0.5;
            #if HAS_DERIVATIVES
              float w = fwidth(sd);
            #else
              // Fallback width when derivatives are unavailable (e.g., older mobile GPUs)
              float w = 0.0025;
            #endif
            float alpha = smoothstep(-w, w, sd);
            if (alpha < 0.01) discard;
            gl_FragColor = vec4(uColor, alpha);
          }
        `,
        };

        material = new THREE.RawShaderMaterial({
          uniforms: {
            uMap: { value: atlasTexture },
            uColor: { value: new THREE.Color(0x000000) },
          },
          vertexShader: shader.vertex,
          fragmentShader: shader.fragment,
          transparent: true,
          extensions: { derivatives: true },
          side: THREE.DoubleSide,
        });

        mesh = new THREE.Mesh(geometry, material);
        scene.add(mesh);

        // Fit camera to mesh bounds (after scaling)
        mesh.updateMatrixWorld(true);
        const meshBox = new THREE.Box3().setFromObject(mesh);
        const size = new THREE.Vector3();
        const center = new THREE.Vector3();
        meshBox.getSize(size);
        meshBox.getCenter(center);
        renderer.setClearColor(0xff0000, 1);

        const span = Math.max(size.x, size.y);
        const margin = Math.max(160, span * 1.2);
        const viewWidth = size.x + margin * 2;
        const viewHeight = size.y + margin * 2;

        camera = new THREE.OrthographicCamera(
          -viewWidth / 2,
          viewWidth / 2,
          viewHeight / 2,
          -viewHeight / 2,
          0.01,
          10,
        );
        camera.position.set(center.x, center.y, 10);
        camera.lookAt(center);

        if (controls) controls.dispose();
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.target.copy(center);
        controls.update();
      }

      function resizeRendererToDisplaySize() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      function render() {
        if (!scene || !camera) return;
        resizeRendererToDisplaySize();
        if (controls) controls.update();
        renderer.render(scene, camera);
      }

      function animate() {
        render();
        requestAnimationFrame(animate);
      }

      async function reload() {
        const jsonPath = document.getElementById("jsonPath").value.trim();
        const textInput = document.getElementById("textInput");
        let text = textInput.value;
        try {
          document.getElementById("loadBtn").disabled = true;
          await loadAtlas(jsonPath);

          const renderables = renderableGlyphs();
          const singleGlyphAtlas = renderables.length === 1;

          if (singleGlyphAtlas) {
            const glyphChar = String.fromCodePoint(renderables[0].id);
            text = glyphChar;
            textInput.disabled = true;
            setStatus(
              `Single-glyph atlas detected; displaying that glyph (U+${renderables[0].id.toString(16).toUpperCase()}).`,
            );
          } else {
            textInput.disabled = false;
            const normalized = normalizeTextForAtlas(text);
            if (normalized !== text) {
              text = normalized;
              textInput.value = text;
              setStatus(`Adjusted text to available glyph: ${text}`);
            }
          }

          setupScene(text);
          render();
        } catch (err) {
          console.error(err);
          setStatus(String(err));
        } finally {
          document.getElementById("loadBtn").disabled = false;
        }
      }

      document
        .getElementById("loadBtn")
        .addEventListener("click", () => reload());
      document
        .getElementById("textInput")
        .addEventListener("change", () => render());
      window.addEventListener("resize", render);

      reload();
      animate();
    </script>
  </body>
</html>
